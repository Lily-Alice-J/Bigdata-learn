## 聊聊分布式锁

### 为什么我们需要一把分布式锁？
```text
    单机体系结构的应用可以通过直接使用同步或ReentrantLock解决多线程资源竞争问题。如果公司业务发展迅速，可以通过部署多个服务节点来提高系统的并行处理能力。 因为本地锁定仅限于当前应用的线程。 在高并发方案中，分布式锁定很有帮助，因为群集中一个APP应用程序的本地锁定不排斥其他APP应用程序的资源访问，而是导致数据不一致。
    在分布式系统中，同一时间只允许一个线程/进程对共享资源进行操作。例如：秒杀、积分扣减、抢红包、定时任务执行等等。
    
    1.为了效率(efficiency)，协调各个客户端避免做重复的工作。即使锁偶尔失效了，只是可能把某些操作多做一遍而已，不会产生其它的不良后果。比如重复发送了一封同样的 email（当然这取决于业务应用的容忍度）。
    2.为了正确性(correctness)。在任何情况下都不允许锁失效的情况发生，因为一旦发生，就可能意味着数据不一致(inconsistency)，数据丢失，文件损坏，订单重复，超卖或者其它严重的问题。
```

### 分布式锁的三个属性
```text
-- 互斥（Mutual Exclusion），这是锁最基本的功能，同一时刻只能有一个客户端持有锁；
-- 避免死锁（Dead lock free），如果某个客户端获得锁之后花了太长时间处理，或者客户端发生了故障，锁无法释放会导致整个处理流程无法进行下去，所以要避免死锁。最常见的是通过设置一个 TTL(Time To Live，存活时间) 来避免死锁。
-- 容错（Fault tolerance），为避免单点故障，锁服务需要具有一定容错性。大体有两种容错方式，一种是锁服务本身是一个集群，能够自动故障切换(ZooKeeper、etcd)；另一种是客户端向多个独立的锁服务发起请求，其中某个锁服务故障时仍然可以从其他锁服务读取到锁信息(Redlock)，代价是一个客户端要获取多把锁，并且要求每台机器的时钟都是一样的，否则 TTL 会不一致，可能有的机器会提前释放锁，有的机器会太晚释放锁，导致出现问题。
```

### 常见的分布式锁实现方案
```text
1.Redis
2.MySQL
3.ZooKeeper
```

#### 基于 Redis 的分布式锁

错误的加锁：非原子操作
```java
public void lock_error1(String lockKey, String requestId, int expireTime) {
RedisCache cache = redisFactory.getRedisCacheInstance(name);
Long result = cache.setnx(lockKey, requestId);
if (result == 1) {
// 加锁和设置超时两个操作是分开的，并非原子操作。假设加锁成功，但是设置锁超时失败，那么该 lockKey 永不失效 将发生死锁。
cache.expireSeconds(lockKey, expireTime);
}
}
```

问题：为什么这个锁必须要设置一个过期时间？
```text
当一个客户端获取锁成功之后，假如它崩溃了，或者它忘记释放锁，或者由于发生了网络分割（network partition）导致它再也无法和 Redis 节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了。
```

正确的加锁姿势
```shell
SET lockKey requestId NX PX 30000

lockKey 是加锁的锁名；
requestId 是由客户端生成的一个全局唯一随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的；这个可避免释放别人的锁；
NX 表示只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁；
PX 30000 设置过期时间，表示这个锁有一个 30 秒的自动过期时间。当然，这里 30 秒只是一个例子，客户端可以选择合适的过期时间。
```
```java
String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime)
```
```text
1.加锁；
2.业务操作；
3.主动释放锁；
4.如果主动释放锁失败了，则达到超时时间，Redis 自动释放锁。Java 代码里在 finally 中释放锁，即无论代码执行成功或者失败，都要释放锁。
```
释放锁的问题：非原子操作
```java
// 获取该锁的requestId值 && 判断是否是自己加的锁 
// 有可能在判断是否是自己加的锁这步阻塞 导致过期时间到删除锁，另一线程得到，而后续上衣线程从阻塞中恢复过来，执行 DEL 操纵，释放掉了这一线程持有的锁
if (jedis.get(lockKey).equals(requestId)) {
    // 删除锁
    jedis.del(lockKey);
    return true;
}
return false;
```
正确的释放锁姿势
```text
问题的根源：锁的判断在客户端，但是锁的删除却在服务端！
正确的释放锁姿势——锁的判断和删除都在服务端（Redis），使用 lua 脚本保证原子性：
```
```java
public class JedisCommandLock {

    private static final Long RELEASE_SUCCESS = 1L;

    /**
     * 功能：释放分布式锁
     * @param jedis        Redis客户端
     * @param lockKey      锁
     * @param requestId    请求标识
     * @return             是否释放成功
     */
    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {
        // Lua 脚本，将判断锁和释放锁变为一步操作
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
        // eval()方法，是将Lua代码交给Redis服务端执行
        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));
        return RELEASE_SUCCESS.equals(result);
    }
}
```

锁超时问题

如果客户端请求锁成功了，但是由于业务处理、GC、操作系统等原因导致它处理时间过长，超过了锁的时间，这时候 Redis 会自动释放锁，这种情况可能导致问题。
```text
如何解决这种问题？---- 续期，Java 里我们可以使用 TimerTask 类来实现自动续期的功能。
这个机制在 Redisson 框架中已经实现，而且还有一个比较霸气的名字 watchdog（看门狗）：加锁时没有指定加锁时间时会启用 watchdog 机制，默认加锁 30 秒，每 10 秒钟检查一次，如果存在就重新设置 过期时间为 30 秒（即 30 秒之后它就不再续期了）
```

Redis 主从架构数据同步复制问题

丢失数据场景：当网络发生脑裂（split-brain）或者 partitioned cluster 集群分裂为多数派与少数派，如果数据继续写入少数派的 Master，则当 Cluster 感知，并停止少数派 Master，或者重新选主时，则面临丢失刚才已写入少数派的数据
```text
解决办法1： WAIT 命令
WAIT 命令作用：WAIT 命令阻塞当前客户端，直到所有先前的写入命令成功传输，并且由至少指定数量的副本（slave）确认。在主从、sentinel 和 Redis 群集故障转移中， WAIT 能够增强（仅仅是增强，但不是保证）数据的安全性，但不能保证 Redis 的强一致性。

解决办法2：Redlock 算法
在 Redlock 之前，很多人对于分布式锁的实现都是基于单个 Redis 节点的。而 Redlock 是基于多个 Redis 节点（都是 Master）的一种实现。前面基于单 Redis 节点的算法是 Redlock 的基础。

1.获取当前时间 T1（毫秒数）。
2.
```